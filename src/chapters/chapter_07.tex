%! Author = adrien koumgang tegantchouang
%! Date = 09/07/24


\chapter{Conclusions}\label{ch:conclusions}


In the need to solve a specific problem in the field of operating systems, that of optimising the execution of processes and threads,
Prof. Frédéric Peschanshi and Prof. Antoine Genitrini gave me the opportunity to work on this thesis on modular decomposition.
Modular decomposition will enable us to decompose the set of processes into modules and obtain an execution order to optimise their overall execution, thus increasing overall execution performance.

This thesis investigated the complex and powerful concept of modular decomposition in graph theory.
Modular decomposition of graphs is a fundamental technique that simplifies the structural analysis of complex networks by dividing them into smaller, more manageable subgraphs, called modules.
Through this process, many computational problems become easier to solve, allowing more efficient algorithms to be used to solve them.

A significant portion of the research was dedicated to the exploration and implementation of modular decomposition algorithms in different programming languages, namely Rust and C++.
The decision to implement the algorithm in Rust stemmed from its growing reputation as a systems programming language that offers both performance and safety.
Rust’s strict ownership model, combined with its emphasis on memory safety without the need for a garbage collector, makes it ideal for performance-critical tasks such as graph decomposition on large datasets.
All this is based on work previously done by Eleni Pistiloglou, who made a Python implementation of the algorithm.
One of the primary challenges in Python's implementation was the inefficiency in handling large graph structures due to its reliance on dynamic typing and high-level abstractions.
While Python is versatile and user-friendly, its inherent limitations in performance become evident when dealing with computationally intensive tasks.

The transition from Python to Rust was not without its challenges.
Rust’s ownership model and its strict borrowing rules, while advantageous in terms of preventing memory errors, required careful handling during the implementation of recursive functions and complex data structures.
One of the key achievements of this thesis was the successful adaptation of modular decomposition algorithms to Rust’s stringent memory and concurrency requirements.

The C++ implementation that was developed in parallel turned out to present many more bugs than the Rust version, largely due to the complexities of manual memory management and the lack of built-in safety guarantees.
In C++, issues such as memory leaks, dangling pointers, and undefined behavior were more prevalent, requiring careful debugging and additional safeguards to ensure stability.
These problems arose because C++ does not enforce strict ownership and borrowing rules like Rust, making it easier to inadvertently introduce errors that compromise the integrity of the program.
In contrast, Rust’s ownership model and built-in safety features, such as the borrow checker, eliminated many of these potential issues at compile-time, resulting in cleaner, more reliable code with fewer runtime errors.

Benchmarking results were a pivotal part of the research.
By testing the Rust implementation on various graph sizes, ranging from small graphs of 10 nodes to much larger graphs of 800 nodes, the thesis provided a comprehensive analysis of the algorithm’s scalability.
The results clearly showed that Rust’s performance significantly surpassed that of Python, especially as the size of the graphs increased.
For small graphs, the difference in execution time between Rust and Python was minimal, but as the graph size grew, Rust’s superior memory management and execution speed became more apparent.

For me, this thesis work was very important because it gave me the opportunity to learn a very promising programming language, Rust.
Nowadays, I use Rust for other applications such as distributed systems, as well as for web programming.
It also enabled me to learn a lot about modular decomposition and the opportunities it offers in various areas of everyday life.
Like, for example, to optimise the execution of processes and threads in computers.
This could greatly increase the performance of the systems and applications we use every day.

This thesis also lays the groundwork for further investigations.
Future work could focus on optimizing the algorithm even further,
exploring parallelization techniques in Rust to handle even larger datasets or more complex graph structures.
Additionally, the modular decomposition algorithm could be extended to other types of graphs and applied to real-world datasets,
such as those used in social network analysis or biological networks, to further validate its effectiveness and scalability.
An opportunity to resolve bug problems in the C++ version and test its performance against the Rust implementation.
The latter could well offer suggestions for improving the current version of Rust.
Ultimately, the modular decomposition of graphs, though rooted in theoretical graph theory, has broad implications across numerous domains.
As datasets continue to grow in size and complexity, the need for efficient and scalable algorithms will only increase,
and the work presented in this thesis provides a valuable tool for researchers and engineers alike.

